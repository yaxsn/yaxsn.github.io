
    <!DOCTYPE html>
    <html lang="en"
            
          
    >
    <head>
    <meta charset="utf-8">
    

    

    
    <title>
        c语言指针 |
        
        欢迎来到浅笙的阅读小屋</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CUbuntu%20Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
    
<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/v4-font-face.min.css">

    
<link rel="stylesheet" href="/css/loader.css">

    <meta name="description" content="C语言指针初识地址 什么是地址：内存是由很多得内存单元(字节)组成的,每个字节都有唯一的编号，这个编号就叫做地址。    我们原先学过的变量、数组、函数等都是放在内存中的，我们可以通过名字去使用变量、数组、函数等，但实际运行时，系统使用得是内存地址，而不是变量名，变量名只是方便我们程序员使用的。  怎么获得变量的地址呢？  前面我们学习过scanf函数，在输入数据时用到了&amp;符号，这个符号就">
<meta property="og:type" content="article">
<meta property="og:title" content="c语言指针">
<meta property="og:url" content="http://yuanaxin.cn/2023/07/12/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/index.html">
<meta property="og:site_name" content="欢迎来到浅笙的阅读小屋">
<meta property="og:description" content="C语言指针初识地址 什么是地址：内存是由很多得内存单元(字节)组成的,每个字节都有唯一的编号，这个编号就叫做地址。    我们原先学过的变量、数组、函数等都是放在内存中的，我们可以通过名字去使用变量、数组、函数等，但实际运行时，系统使用得是内存地址，而不是变量名，变量名只是方便我们程序员使用的。  怎么获得变量的地址呢？  前面我们学习过scanf函数，在输入数据时用到了&amp;符号，这个符号就">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20210728160818569.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20220720160425846.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20210728163452903.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20210728164145489.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20220720162037899.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20220720164614597.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20220216200008510.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20210810165241531.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20211123015114297.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/1J35014B-0.jpg">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/1J3506331-1.jpg">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20211123174153315.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20211123174201553.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20211123202639418.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20211126140138880.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20211126140408068.png">
<meta property="og:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20211126140614455.png">
<meta property="article:published_time" content="2023-07-11T19:26:38.000Z">
<meta property="article:modified_time" content="2023-07-11T19:27:50.730Z">
<meta property="article:author" content="浅笙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/%E6%A1%8C%E9%9D%A2/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/img/image-20210728160818569.png">
    
        <link rel="alternate" href="/atom.xml" title="欢迎来到浅笙的阅读小屋" type="application/atom+xml">
    
    
        <link rel="shortcut icon" href="/images/001.ico">
    
    
        
<link rel="stylesheet" href="https://unpkg.com/typeface-source-code-pro@1.1.13/index.css">

    
    
<link rel="stylesheet" href="/css/style.css">

    
        
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

    
    
    
    
    
<script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script>

    
        
<link rel="stylesheet" href="https://unpkg.com/wowjs@1.1.3/css/libs/animate.css">

        
<script src="https://unpkg.com/wowjs@1.1.3/dist/wow.min.js"></script>

        <script>
          new WOW({
            offset: 0,
            mobile: true,
            live: false
          }).init();
        </script>
    
<meta name="generator" content="Hexo 6.3.0"></head>

    <body>
    
<div id='loader'>
  <div class="loading-left-bg"></div>
  <div class="loading-right-bg"></div>
  <div class="spinner-box">
    <div class="loading-taichi">
      <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
      <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b" />
      <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00" />
      <path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00" />
    </svg>
    </div>
    <div class="loading-word">少女祈祷中...</div>
  </div>
</div>
</div>

<script>
  const endLoading = function() {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('load', endLoading);
  document.getElementById('loader').addEventListener('click', endLoading);
</script>


    <div id="container">
        <div id="wrap">
            <header id="header">
    
        <img data-src="/images/banner.jpg" data-sizes="auto" alt="c语言指针" class="lazyload">
    
    <div id="header-outer" class="outer">
        <div id="header-title" class="inner">
            <div id="logo-wrap">
                
                    
                    
                        <a href="/" id="logo"><h1>c语言指针</h1></a>
                    
                
            </div>
            
                
                
            
        </div>
        <div id="header-inner">
            <nav id="main-nav">
                <a id="main-nav-toggle" class="nav-icon"></a>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/">Home</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/archives">Archives</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/about">About</a>
                    </span>
                
                    <span class="main-nav-link-wrap">
                        <span class="main-nav-icon"></span>
                        <a class="main-nav-link" href="/friend">Friend</a>
                    </span>
                
            </nav>
            <nav id="sub-nav">
                
                    <a id="nav-rss-link" class="nav-icon" href="/atom.xml"
                       title="RSS Feed"></a>
                
                
            </nav>
            <div id="search-form-wrap">
                <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yuanaxin.cn"></form>
            </div>
        </div>
    </div>
</header>

            <div id="content" class="outer">
                <section id="main"><article id="post-c语言指针" class="h-entry article article-type-post"
         itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
    <div class="article-inner">
        <div class="article-meta">
            <div class="article-date wow slideInLeft">
    <a href="/2023/07/12/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" class="article-date-link">
        <time datetime="2023-07-11T19:26:38.000Z"
              itemprop="datePublished">2023-07-12</time>
    </a>
</div>

            

        </div>
        <div class="hr-line"></div>
        

        <div class="e-content article-entry" itemprop="articleBody">
            
                <h1 id="C语言指针初识"><a href="#C语言指针初识" class="headerlink" title="C语言指针初识"></a>C语言指针初识</h1><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><ul>
<li>什么是地址：内存是由很多得内存单元(字节)组成的,每个字节都有唯一的编号，这个编号就叫做地址。</li>
</ul>
<p><img src="D:/桌面/全栈开发/img/image-20210728160818569.png" alt="image-20210728160818569"></p>
<ul>
<li>我们原先学过的变量、数组、函数等都是放在内存中的，我们可以通过名字去使用变量、数组、函数等，但实际运行时，系统使用得是内存地址，而不是变量名，变量名只是方便我们程序员使用的。</li>
</ul>
<p><strong>怎么获得变量的地址呢？</strong></p>
<ul>
<li><p>前面我们学习过scanf函数，在输入数据时用到了&amp;符号，这个符号就是获取变量的地址的符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">//输出age变量的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;addr:%p\n&quot;</span>,&amp;age);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>每个内存单元之间地址是连续的</li>
<li>在同一台机器上每个内存单元的地址是唯一的</li>
<li>每次运行程序，变量的地址不一定一样，这是由操作系统随机分配的</li>
</ul>
<h2 id="首地址"><a href="#首地址" class="headerlink" title="首地址"></a>首地址</h2><p>首地址就是该变量所占的存储区域中的第一个单元的地址。</p>
<ul>
<li><p>以一个整型来说，需要四个字节来存储，那么每个字节都有一个地址，但是我们取地址得到的只有一个地址，这个地址叫做首地址。（大家理解这个概念就好，一般不会这么叫，就直接叫变量的地址了）</p>
</li>
<li><p>为了便于访问，一个变量所占用的这几个内存单元都是连续存放，地址连续的几个单元通常就叫做一个“存储区域”。</p>
<p><img src="D:/桌面/全栈开发/img/image-20220720160425846.png" alt="image-20220720160425846"></p>
</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针实际上是一种特殊的数据类型，我们可以用来申明指针变量，用来存储地址。</p>
<p><img src="D:/桌面/全栈开发/img/image-20210728163452903.png" alt="image-20210728163452903"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *p1,*p2,*p3;	</span><br></pre></td></tr></table></figure>

<p>同时定义多个指针变量时，每个标识符前面都要加*号，否则后面的会被定义成int型变量。</p>
<p><strong>取地址我们已经学习过了，那么怎么根据指针获取对应的内存的数据呢？</strong></p>
<p>&amp;：取地址符。用于获取变量所在的首地址</p>
<p>*：间接访问运算符，也叫作解引用运算符。用于获取地址对应的值。</p>
<p>这两个运算符的优先级一样，结合起来使用也非常简单！(如果不理解，最好加上括号；如：*(&amp;p))</p>
<p><img src="D:/桌面/全栈开发/img/image-20210728164145489.png" alt="image-20210728164145489"></p>
<p>指针作为一个变量是有大小的，其大小在32位平台是4个字节，64位平台上是8个字节，大小与指针的类型无关。</p>
<p><img src="D:/桌面/全栈开发/img/image-20220720162037899.png" alt="image-20220720162037899"></p>
<p>![image-20220720162100057](D:&#x2F;C语言从入门到放弃&#x2F;10 指针初识&#x2F;assets&#x2F;image-20220720162100057.png)</p>
<p>上图以64位平台为例，可以看到无论指针是整型、字符型、浮点型也无论一级指针还是二级指针，其在内存空间所占的大小都是4个字节。</p>
<p><strong>使用指针的好处：</strong></p>
<ul>
<li>1、直接访问硬件</li>
<li>2、快速传递数据（指针表示地址）</li>
<li>3、返回一个以上的值，返回一个（数组或者结构体的指针）</li>
<li>4、方便处理字符串</li>
</ul>
<h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h2><p>指针使用来间接访问内存的，那么就需要知道指针指向的是什么样的数据类型，应该如何解析它。</p>
<p>所以我们需要一个特定类型的指针变量来存放特定类型变量的地址。</p>
<ul>
<li>int*  -&gt;  int</li>
<li>char* - &gt; char</li>
<li>double* -&gt; double</li>
<li>int* - &gt;char   <font color=red>错误！错误！错误!</font></li>
</ul>
<p>为什么这么麻烦呢？指针不就是存储一个地址吗，为什么不能用一个通用的指针类型，来存储所有类型变量的地址呢？</p>
<p>因为，我们不仅仅使用指针来存储内存地址；同时也是用它来解引用那些地址的内容。这样我们就可以访问和修改这些地址对应的值了。</p>
<p>正如你所知，不同的数据类型有不同的大小，char 1个字节，int 4个字节，double 8个字节。不仅仅是大小方面的差异，这些变量或数据类型在存储信息的方式上也有所不同。</p>
<p><img src="D:/桌面/全栈开发/img/image-20220720164614597.png" alt="image-20220720164614597"></p>
<p>上图所示，如果是int类型，那么最高位表示符号位，剩下的31个位用来存储值。</p>
<p>现在如果声明一个指针p指向整型变量，然后用取地址符把a的地址存放在p中，然后打印p，p的值会是多少呢？0x200，也就是byte0的地址，也就是说整型变量a的起始地址是0x200；</p>
<p>如果我们想知道那个地址的内容(值)，就使用*p去解引用这个地址。然后编译器看到之后就会觉得没有问题，p是一个指向整型的指针，因此我们需要看4个字节。从地址0x200开始，编译器就知道如何去提取一个整型数据。所以，它从这四个字节中得到了1025这个值。</p>
<p>如果p是一个字符类型的指针，那么在解引用的时候编译器只会看一个字节，因为一个字符类型只有一个字节。如果p是一个浮点型指针，尽管浮点型也是4个字节，但是浮点数4字节的信息表示缺与整型不一样。打印出来的值也会是不一样的。</p>
<h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h3><p>void* 类型的指针又叫万能指针，他可以指向任意的内存空间地址</p>
<ul>
<li><p>可以指向任何地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maye = <span class="number">20</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;maye;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以隐式自动转换为其他类型指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pi = p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能对void*取值操作，因为它没有类型，或者说不能判断存储的是什么类型，需要强转指定一个确定的类型才能使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);		<span class="comment">//error</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(<span class="type">int</span>*)p);<span class="comment">//right</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指针的特殊状态"><a href="#指针的特殊状态" class="headerlink" title="指针的特殊状态"></a>指针的特殊状态</h2><p>我们在使用指针的时候，总是会遇到各种稀奇古怪的问题，但万变不离其宗，下面我们一起来学习指针的各种状态。</p>
<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>野指针(wild pointer)就是没有被初始化过的指针。</p>
<p>【示例：】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用Vs编译，会直接报错<code>error C4700: 使用了未初始化的局部变量“p”</code>,还是比较人性的，从根本上避免了野指针。</p>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>空指针就是被赋值为NULL的指针，它不指向任何的对象或者函数。（坚决不能使用空指针，否则程序就会崩）</p>
<p>空指针的出现是为了避免错误的引用指针而导致的难以排查的问题，不过空指针也不能直接访问，但是可以用来判断。</p>
<p>【示例：】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//判断指针是否为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把指针值为空，则可以进行判断，就算没有判断，直接对空指针进行引用，产生的报错也非常好理解。</p>
<p><img src="D:/桌面/全栈开发/img/image-20220216200008510.png" alt="image-20220216200008510"></p>
<h3 id="悬空指针"><a href="#悬空指针" class="headerlink" title="悬空指针"></a>悬空指针</h3><p>悬空指针是指针最初指向的内存已经被释放了的一种指针。 </p>
<p>【示例：】从函数中返回临时变量的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">18</span>;   <span class="comment">//函数执行完毕，age的内存会被自动释放</span></span><br><span class="line">    <span class="keyword">return</span> &amp;age;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = foo();</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，貌似没有任何问题，的确如此，但不代表这个代码是正确的。现在我们把main函数中的getchar的注释放开，然后重新运行程序，等待几秒之后按下任意键，发现输出的结果已经不对了。</p>
<p>为什么？一开始的时候我们没有getchar，foo函数返回之后，接着立马输出*p，这个时候函数里面的age还没有来得及释放，所以输出没问题，但是当我们使用getchar等待一段时间后，age有足够的时间释放了，所以就会输出垃圾值。</p>
<p><strong>注意：</strong>悬空指针是编码过程中最容易出现问题的，切记，认真检查！</p>
<h2 id="const-与-指针"><a href="#const-与-指针" class="headerlink" title="const 与 指针"></a>const 与 指针</h2><p>const是constant的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着“只读”。任何修改该变量的尝试都会导致编译错误。const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以我们只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。</p>
<p>const与指针可以搭配出三种不同的含义：</p>
<ul>
<li><p>指针指向的内存不可修改，但指针的指向可以修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;age;		<span class="comment">//常量指针</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* ptr = &amp;age;		<span class="comment">//和上面一句是等价的</span></span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">20</span>;					<span class="comment">//err,不能修改</span></span><br><span class="line">ptr = <span class="literal">NULL</span>;					<span class="comment">//ok,可以修改指向</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针的指向不可以修改，但指向的内存可以修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;age;</span><br><span class="line">*ptr = <span class="number">20</span>;	<span class="comment">//ok</span></span><br><span class="line">ptr = <span class="literal">NULL</span>;	<span class="comment">//err</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针的指向不可以修改，指向的内存也不可以修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;age;</span><br><span class="line">*ptr = <span class="number">20</span>;	<span class="comment">//err</span></span><br><span class="line">ptr = <span class="literal">NULL</span>;	<span class="comment">//err</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>常量指针</strong>(<code>指向常量的指针</code>)是指指向常量的指针，顾名思义，就是指针指向的是常量，即，它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而指向另一个常量。</p>
<p><strong>指针常量</strong>(<code>指针是常量</code>)是指指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。有一点需要注意的是，指针常量在定义时必须同时赋初值。</p>
<h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><p><strong>算数运算：</strong></p>
<ul>
<li><p>指针是存储的地址，地址本质就是一个整数，因此，我们可以对指针执行四种算术运算：++、–、+、-(其他运算没有意义)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>,pc,pc+<span class="number">1</span>);	<span class="comment">//0 1</span></span><br><span class="line"><span class="type">int</span>* pi = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>,pi,pi+<span class="number">1</span>);	<span class="comment">//0 4</span></span><br><span class="line"><span class="type">double</span>* pd = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>,pd,pd+<span class="number">1</span>);	<span class="comment">//0 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>总结:</p>
<ul>
<li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li>
<li>指针的每一次递减，它都会指向前一个元素的存储单元。</li>
<li>指针在递增和递减时跳跃的字节数(步长)取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节</li>
<li>不同类型的指针<strong>所占内存大小都是一样</strong>的(32位计算机4个字节，64位8个字节)</li>
</ul>
</li>
</ul>
<p><strong>关系运算：</strong></p>
<ul>
<li><p>指针可以用关系运算符进行比较，如 &#x3D;&#x3D;、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</p>
</li>
<li><p>总结：</p>
<ul>
<li>对相关变量的指针进行比较，才有意义</li>
<li>大于小于常用在数组中，全等一般是判断指针是否为NULL</li>
</ul>
</li>
</ul>
<h2 id="大、小端模式"><a href="#大、小端模式" class="headerlink" title="大、小端模式"></a>大、小端模式</h2><ul>
<li><p>大端（Big-endian）和小端（Little-endian）是什么？</p>
<ul>
<li>在计算机业界，Endian表示数据在存储器中的存放顺序</li>
</ul>
</li>
<li><p><strong>大端模式</strong>：数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中</p>
<ul>
<li>这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这种存放方式符合人类的正常思维</li>
</ul>
</li>
<li><p><strong>小端模式</strong>：数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中</p>
<ul>
<li>这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。</li>
</ul>
</li>
</ul>
<p><img src="D:/桌面/全栈开发/img/image-20210810165241531.png" alt="image-20210810165241531"></p>
<ul>
<li><strong>总结</strong>：采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将高位存放在低地址，小端方式将高位存放在高地址。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。到目前为止，采用大端或者小端进行数据存放，其孰优孰劣也没有定论。</li>
</ul>
<h1 id="C语言指针与数组"><a href="#C语言指针与数组" class="headerlink" title="C语言指针与数组"></a>C语言指针与数组</h1><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>指针可以指向一个普通类型的数据，例如 int、double、char 等，也可以指向一个指针类型的数据，例如 int *、double *、char * 等。</p>
<p>如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。</p>
<p>假设有一个 int 类型的变量 age，page是指向 age 的指针变量，ppage 又是指向 page 的指针变量，它们的关系如下图所示：</p>
<p><img src="D:/桌面/全栈开发/img/image-20211123015114297.png" alt="image-20211123015114297"></p>
<p>将这种关系转换为C语言代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age =<span class="number">28</span>;</span><br><span class="line"><span class="type">int</span> *page = &amp;age;</span><br><span class="line"><span class="type">int</span> **ppage = &amp;page;</span><br></pre></td></tr></table></figure>

<p>指针变量也是一种变量，也会占用存储空间，也可以使用<code>&amp;</code>获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号<code>*</code>。page 是一级指针，指向普通类型的数据，定义时有一个<code>*</code>；ppage 是二级指针，指向一级指针 page，定义时有两个<code>*</code>。</p>
<p>如果我们希望再定义一个三级指针 p3age，让它指向 ppage，那么可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ***p3age = &amp;ppage;</span><br></pre></td></tr></table></figure>

<p>四级指针也是类似的道理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ****p4age = &amp;p3age;</span><br></pre></td></tr></table></figure>

<p>实际开发中会经常使用一级指针和二级指针，几乎用不到高级指针。</p>
<p>想要获取指针指向的数据时，一级指针加一个<code>*</code>，二级指针加两个<code>*</code>，三级指针加三个<code>*</code>，以此类推，请看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;a;</span><br><span class="line">    <span class="type">int</span> **p2 = &amp;p1;</span><br><span class="line">    <span class="type">int</span> ***p3 = &amp;p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %d\n&quot;</span>, a, *p1, **p2, ***p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p2 = %#X, p3 = %#X\n&quot;</span>, &amp;p2, p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p1 = %#X, p2 = %#X, *p3 = %#X\n&quot;</span>, &amp;p1, p2, *p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n&quot;</span>, &amp;a, p1, *p2, **p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一维数组指针"><a href="#一维数组指针" class="headerlink" title="一维数组指针"></a>一维数组指针</h2><p>数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以<code>int arr[] = &#123; 99, 15, 100, 888, 252 &#125;;</code>为例，该数组在内存中的分布如下图所示：</p>
<p><img src="D:/桌面/全栈开发/img/1J35014B-0.jpg" alt="img"></p>
<p>定义数组时，要给出数组名和数组长度，数组名可以认为是一个<code>指针</code>，它指向数组的第 0 个元素。在C语言中，我们将第 0 个元素的地址称为数组的首地址。以上面的数组为例，下图是 arr 的指向：</p>
<p><img src="D:/桌面/全栈开发/img/1J3506331-1.jpg" alt="img"></p>
<p><strong>数组下标为啥从0开始？</strong></p>
<ul>
<li>数组下标实际上是每个元素的地址相对于第一个元素地址的偏移量</li>
</ul>
<p><img src="D:/桌面/全栈开发/img/image-20211123174153315.png" alt="image-20211123174153315"></p>
<p><img src="D:/桌面/全栈开发/img/image-20211123174201553.png" alt="image-20211123174201553"></p>
<p>访问数组元素除了可以通过<em>下标法</em>之外，还可以通过<em>指针法</em>访问。</p>
<ul>
<li><p>下标法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    <span class="comment">//printf(&quot;%d &quot;,i[arr]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(arr + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是为什么在某些地方大家会看到 <strong>i[arr]</strong> 这种访问数组元素的方法的原因，实际上下标法就是通过指针法来实现的，只不过编译器帮助我们做了这个操作，简化了操作难度。</p>
</li>
</ul>
<h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><p>我们也可以定义一个指向数组的指针，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">99</span>, <span class="number">15</span>, <span class="number">100</span>, <span class="number">888</span>, <span class="number">252</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br></pre></td></tr></table></figure>

<p>arr 本身可以看做是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以<code>int *p = arr;</code>也可以写作<code>int *p = &amp;arr[0];</code>。也就是说，arr、p、&amp;arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。</p>
<p>如果一个指针指向了数组，我们就称它为<strong>数组指针（Array Pointer）</strong>。</p>
<p>数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是<code>int *</code>。</p>
<p>反过来想，p 并不知道它指向的是一个数组，p 只知道它指向的是一个整数，究竟如何使用 p 取决于程序员的编码。</p>
<p>使用指针访问数组元素和使用函数名没有任何区别，值得注意的是我们不同通过指针获得数组的大小，但是通过数组名却可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(arr));		<span class="comment">//数组所占字节数 20 Byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(p));		<span class="comment">//指针所占字节数 4 Byte</span></span><br></pre></td></tr></table></figure>

<p>也就是说，根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。不像字符串，数组本身也没有特定的结束标志，如果不知道数组的长度，那么就无法遍历整个数组。</p>
<h3 id="关于数组指针的谜题"><a href="#关于数组指针的谜题" class="headerlink" title="关于数组指针的谜题"></a>关于数组指针的谜题</h3><p>假设 p 是指向数组 arr 中第 n 个元素的指针，那么 *p++、*++p、(*p)++ 分别是什么意思呢？</p>
<p>*p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素。</p>
<p>*++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。</p>
<p>(*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。</p>
<h3 id="数组名和数组指针的区别"><a href="#数组名和数组指针的区别" class="headerlink" title="数组名和数组指针的区别"></a>数组名和数组指针的区别</h3><p>虽然说数组名可以当做指针使用，但实际上数组名并不等价于指针。</p>
<ul>
<li>数组名代表的是整个数组，具有确定数量的元素</li>
<li>指针是一个标量，不能确定指向的是否是一个数组</li>
<li>数组可以在某些情况下会自动转换为指针，当数组名在表达式中使用时，编译器会把数组名转换为一个指针常量，是数组中的第一个元素的地址，类型就是数组元素的地址类型(通过sizeof也可以看出来)</li>
</ul>
<h2 id="二维数组指针"><a href="#二维数组指针" class="headerlink" title="二维数组指针"></a>二维数组指针</h2><p>二维数组可以理解为每一个元素都是一个一维数组的数组，这样就可以很好的理解二维数组与指针了。</p>
<p>下面定义了一个2行3列的二维数组，并画出了对应的内存模型。</p>
<p><img src="D:/桌面/全栈开发/img/image-20211123202639418.png" alt="image-20211123202639418"></p>
<p>我们可以使用arr[0]获得第0个一维数组，然后再加上一个小标就可以获取到对应的元素，如arr[0][0]获取了第0行第0列的元素。</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>动态内存是相对静态内存而言的。所谓动态和静态就是指内存的分配方式。动态内存是指在堆上分配的内存，而静态内存是指在栈上分配的内存。</p>
<p>前面所写的程序大多数都是在栈上分配的，比如局部变量、形参、函数调用等。栈上分配的内存是由系统分配和释放的，空间有限，在复合语句或函数运行结束后就会被系统自动释放。而堆上分配的内存是由程序员通过编程自己手动分配和释放的，空间很大，存储自由。堆和栈后面还会专门讲，这里先了解一下。</p>
<p><strong>动态分配意义</strong></p>
<ul>
<li>定义数组时必须指定数组的大小，使用动态分配可以在运行时调整大小。</li>
<li>突破函数内局部变量的作用域局限，函数结束之后，不希望变量的内存被释放。</li>
</ul>
<h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>那么动态内存是怎么造出来的？在讲如何动态地把一个数组造出来之前，我们必须要先介绍 malloc 函数的使用。</p>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>malloc 是一个系统函数，它是 <code>memory allocate</code> 的缩写。其中memory是“内存”的意思，allocate是“分配”的意思。顾名思义 malloc 函数的功能就是“分配内存”。要调用它必须要包含头文件&lt;stdlib.h&gt;。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> _Size)</span></span>;</span><br><span class="line"><span class="type">int</span>* parr = <span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>malloc 函数只有一个形参，并且是整型。该函数的功能是在内存的动态存储空间即堆中分配一个长度为size的连续空间。函数的返回值是一个指向所分配内存空间起始地址的指针，类型为 void*型。</p>
<p>简单的理解，malloc 函数的返回值是一个地址，这个地址就是动态分配的内存空间的起始地址。如果此函数未能成功地执行，如内存空间不足，则返回空指针 NULL。</p>
<p>“int i&#x3D;5；”表示分配了 4 字节的“静态内存”。这里需要强调的是：“静态内存”和“静态变量”虽然都有“静态”两个字，但是它们没有任何关系。不要以为“静态”变量的内存就是“静态内存”。静态变量的关键字是 static，它与全局变量一样，都是在“静态存储区”中分配的。这块内存在程序编译的时候就已经分配好了，而且在程序的整个运行期间都存在；而静态内存是在栈中分配的，比如局部变量。</p>
<h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><p>calloc函数的功能与malloc函数的功能相似，都是从堆分配内存。最大的不同在于calloc会把申请的空间全部初始化为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> _Count,<span class="type">size_t</span> _Size)</span></span>;</span><br><span class="line"><span class="type">int</span>* parr = <span class="built_in">calloc</span>(<span class="number">10</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><p>realloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span>*  _Block,<span class="type">size_t</span> _Size)</span></span>;</span><br><span class="line"><span class="type">int</span>* pnew = <span class="built_in">realloc</span>(parr,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>_Block是堆上已经存在空间的地址</li>
<li>_Size是目标空间大小</li>
</ul>
<p>重新分配堆上的void指针_Block所指的空间为_Size个字节，同时会复制原有内容到新分配的堆上存储空间。注意，若_Size小于或等于原来空间的字节，则保持不变。否则会扩容。</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>前面讲过，动态分配的内存空间是由程序员手动编程释放的。那么怎么释放呢？用 free 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* _Block)</span></span>;</span><br></pre></td></tr></table></figure>

<p>free 函数无返回值，它的功能是释放指针变量 p 所指向的内存单元。此时 p 所指向的那块内存单元将会被释放并还给操作系统，不再归它使用。操作系统可以重新将它分配给其他变量使用。</p>
<p>需要注意的是，释放并不是指清空内存空间，而是指将该内存空间标记为“可用”状态，使操作系统在分配内存时可以将它重新分配给其他变量使用。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>动态创建的内存如果不用了必须要释放。注意，一个动态内存只能释放一次。如果释放多次程序就会崩溃，因为已经释放了，不能再释放第二次。</p>
<p>malloc 和 free 一定要成对存在，一一对应。有 malloc 就一定要有 free，有几个 malloc 就要有几个 free，与此同时，每释放一个指向动态内存的指针变量后要立刻把它指向 NULL。</p>
<p>最后需要强调的是，只有动态创建的内存才能用 free 把它释放掉，静态内存是不能用free释放的。静态内存只能由系统释放。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">free(p);	//error</span><br></pre></td></tr></table></figure>

<p>如果试图用 free(p) 把指针变量 p 所指向的内存空间释放掉，那么编译的时候不会出错，但程序执行的时候立刻就出错。</p>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>每个元素都是指针的数组叫做指针数组，即存储指针的数组。</p>
<p>如：<code>int* parr[5] = &#123;NULL&#125;;</code></p>
<p>parr里面存的是int*型指针，同时我们把每个指针都初始化为了NULL。接下来我们让这个数组的每个元素都指向一块动态分配的空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    parr[i] = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *parr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><ol>
<li><p>若有 <code>int a[5][5],**p;</code>下面赋值正确的是（  ）</p>
<p>A. p &#x3D; a				B. p &#x3D; *a				C. p &#x3D; &amp;a[0][0]				D. 都不对</p>
</li>
<li><p>下列代码输出结果是多少（  ）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>


</li>
<li><p>以下代码输出结果是什么（  ）</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;I_Love_you_girl&quot;</span>;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)(str + <span class="number">2</span>);</span><br><span class="line">*ptr = <span class="string">&#x27;maye&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>以下代码输出结果是什么（  ）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>) &#125;;</span><br><span class="line"><span class="type">int</span>* p = a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>以下代码输出结果是什么（  ）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> cc = (a + <span class="number">1</span>)[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cc);</span><br></pre></td></tr></table></figure>

<h1 id="C语言函数指针"><a href="#C语言函数指针" class="headerlink" title="C语言函数指针"></a>C语言函数指针</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>C语言允许用户使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等</p>
<p>在使用复杂指针类型时，比如函数指针，可以用typedef取别名，不需要每次都写很长的指针定义。</p>
<p><strong>定义：typedef 类型 别名；</strong></p>
<ul>
<li>typedef int INT；INT就是我们定义的新类型，此时可以用INT 代替int来定义整型变量</li>
<li>typedef void (*PFUNA)(int a); ———— 在语句开头加上typedef关键字，PFUNA就是我们定义的新类型</li>
</ul>
<p><strong>一，typedef的一个重要用途是定义机器无关的类型。</strong></p>
<p>例如，定义一个叫REAL的浮点类型，该浮点类型在目标机器上可以获得最高的精度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> Real;</span><br></pre></td></tr></table></figure>

<p>如果在不支持 long double 的机器上运行相关代码，只需要对对应的typedef语句进行修改，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Real;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> Real</span><br></pre></td></tr></table></figure>

<p><strong>二，使用typedef为现有类型创建别名，给变量定义一个易于记忆且意义明确的新名字。</strong></p>
<ul>
<li>类型过长，用typedef可以简化一下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UInt32</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以定义数组类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> IntArray[<span class="number">10</span>];</span><br><span class="line">IntArray arr;				<span class="comment">//相当于int arr[10]</span></span><br></pre></td></tr></table></figure>



<p><strong>三、使用typedef简化一些比较复杂的类型声明。</strong></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*CompareCallBack)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上述声明引入了PFUN类型作为函数指针的同义字，该函数有两个类型分别为int、int、char参数，以及一个类型为int的返回值。通常，当某个函数的参数是一个回调函数时，可能会用到typedef简化声明。<br>例如，承接上面的示例，我们再列举下列示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callBackTest</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,CompareCallBack cmp)</span>;</span><br></pre></td></tr></table></figure>

<p>callBackTest函数的参数有一个CompareCallBack类型的回调函数。在这个示例中，如果不用typedef，callBackTest函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callBackTest</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> (*cmp)(<span class="type">int</span>,<span class="type">int</span>))</span>;</span><br></pre></td></tr></table></figure>


<p>从上面两条函数声明可以看出，不使用typedef的情况下，callBackTest函数的声明复杂得多，不利于代码的理解，并且增加的出错风险。</p>
<p>所以，在某些复杂的类型声明中，使用typedef进行声明的简化是很有必要的。</p>
<h2 id="小心陷阱"><a href="#小心陷阱" class="headerlink" title="小心陷阱"></a>小心陷阱</h2><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* IntPtr;</span><br><span class="line">cont IntPtr p;</span><br></pre></td></tr></table></figure>

<p><strong><code>const IntPtr</code> 相当于 <code>const int</code>” 呢？还是<code>int* const</code>呢？</strong></p>
<ul>
<li>答案是相当于<code>char* const</code>，原因很简单，typedef 是用来定义一种类型的新别名的，它不同于宏，不是简单的字符串替换。</li>
<li>因此，<code>const IntPtr</code>中的 const 给予了整个指针本身常量性，也就是形成了常量指针<code>char* const</code>（一个指向char的常量指针），而不是<code>const char*</code>（指向常量 char 的指针）。</li>
<li>当然，要想让 const IntPtr相当于 const char* 也很容易。如下面的代码所示：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span>* const_IntPtr;</span><br><span class="line">const_IntPtr p;</span><br></pre></td></tr></table></figure>


<p>还值得注意的是，虽然 typedef 并不真正影响对象的存储特性，但在语法上它还是一个存储类的关键字，就像 auto、extern、static 和 register 等关键字一样。因此，像下面这种声明方式是不可行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">static</span> <span class="type">int</span> Static_Int;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>不可行的原因是不能声明多个存储类关键字，由于 typedef 已经占据了存储类关键字的位置，因此，在 typedef 声明中就不能够再使用 static 或任何其他存储类关键字了。</p>
<h2 id="指针做函数参数"><a href="#指针做函数参数" class="headerlink" title="指针做函数参数"></a>指针做函数参数</h2><p>学习函数的时候，讲了函数的参数都是值拷贝，在函数里面改变形参的值，实参并不会发生改变。</p>
<img src="D:/桌面/全栈开发/img/image-20211126140138880.png" alt="image-20211126140138880" style="zoom:80%;" />

<p>如果想要通过形参改变实参的值，就需要传入指针了。</p>
<p><img src="D:/桌面/全栈开发/img/image-20211126140408068.png" alt="image-20211126140408068"></p>
<p>注意：虽然指针能在函数里面改变实参的值，但是函数传参还是值拷贝。不过指针虽然是值拷贝，但是却指向的同一片内存空间。</p>
<img src="D:/桌面/全栈开发/img/image-20211126140614455.png" alt="image-20211126140614455" style="zoom:80%;" />

<ul>
<li>数组当做指针传参</li>
</ul>
<h2 id="指针做函数返回值"><a href="#指针做函数返回值" class="headerlink" title="指针做函数返回值"></a>指针做函数返回值</h2><p>返回指针的函数，也叫作指针函数。</p>
<p>和普通函数一样，只是返回值类型不同而已，先看一下下面这个函数，非常熟悉对不！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>接下来看另外一个函数声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样一对比，发现所谓的指针函数也没什么特别的。</p>
<p><strong>注意：</strong></p>
<ul>
<li>不要返回临时变量的地址</li>
<li>可以返回动态申请的空间的地址</li>
<li>可以返回静态变量和全局变量的地址</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>如果在程序中定义了一个函数，那么在运行时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p>
<h3 id="函数指针定义"><a href="#函数指针定义" class="headerlink" title="函数指针定义"></a>函数指针定义</h3><p><code>函数返回值类型  (* 指针变量名) (函数参数列表);</code></p>
<ul>
<li><p>“函数返回值类型”表示该指针变量所指向函数的 返回值类型；</p>
</li>
<li><p>“函数参数列表”表示该指针变量所指向函数的参数列表。</p>
</li>
</ul>
<p><strong>那么怎么判断一个指针变量是指向变量的指针，还是指向函数的指针变量呢？</strong></p>
<ul>
<li><p>看变量名的后面有没有带有形参类型的圆括号，如果有就是指向函数的指针变量，即函数指针，如果没有就是指向变量的指针变量。</p>
</li>
<li><p>函数指针没有++和 –运算</p>
</li>
</ul>
<h3 id="函数指针使用"><a href="#函数指针使用" class="headerlink" title="函数指针使用"></a>函数指针使用</h3><p>定义一个实现两个数相加的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*pfun)(<span class="type">int</span>,<span class="type">int</span>) = add;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">pfun</span>(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res:%d\n&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在给函数指针pfun赋值时，可以直接用add赋值，也可以用&amp;add赋值，效果是一样的。</p>
<p>在使用函数指针时，同样也有两种方式，1，pfun(5,3);  2，(*pfun)(5,3)</p>
<p><strong>用函数指针实现一个简单的计算器，支持+、-、*、&#x2F;、%</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plus sub multi divide mod		<span class="comment">//加 减 乘 除 取余</span></span><br></pre></td></tr></table></figure>

<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>首先要明确的一点是，函数也可以作为函数的参数来传递。</p>
<p>当做函数参数传入的函数，称之为 回调函数（至于为什么要叫“回调函数”，不能叫别的呢？其实这只是人为规定的一个名字。你也可以叫“顿开专属函数”，但是到时候你又会问为什么要叫“顿开专属函数”，它特么的总的有个名字吧！所以叫“回调函数”就是王八的屁股：规定！）。</p>

            
        </div>
        <footer class="article-footer">
            <a data-url="http://yuanaxin.cn/2023/07/12/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" data-id="cljyp7zyx0004k0ah0oof3982" data-title="c语言指针"
               class="article-share-link">Share</a>
            
            
            
            

        </footer>
    </div>
    
        
    <nav id="article-nav" class="wow fadeInUp">
        
            <div class="article-nav-link-wrap article-nav-link-left">
                
                    
                    
                        <img data-src="https://cdn.pixabay.com/photo/2015/04/25/12/39/girls-739071_1280.jpg" data-sizes="auto" alt="c语言结构体" class="lazyload">
                    
                
                <a href="/2023/07/12/c%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/"></a>
                <div class="article-nav-caption">Newer</div>
                <h3 class="article-nav-title">
                    
                        c语言结构体
                    
                </h3>
            </div>
        
        
    </nav>


    
</article>











</section>
                
                    <aside id="sidebar">
    <div class="sidebar-wrap wow fadeInRight">
        <div class="sidebar-author">
            <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="浅笙" class="lazyload">
            <div class="sidebar-author-name">浅笙</div>
            <div class="sidebar-description">QQ:3561409438</div>
        </div>
        <div class="sidebar-state">
            <div class="sidebar-state-article">
                <div>Posts</div>
                <div class="sidebar-state-number">5</div>
            </div>
            <div class="sidebar-state-category">
                <div>Categories</div>
                <div class="sidebar-state-number">0</div>
            </div>
            <div class="sidebar-state-tag">
                <div>Tags</div>
                <div class="sidebar-state-number">0</div>
            </div>
        </div>
        <div class="sidebar-social">
            
                <div class=icon-github>
                    <a href=https://github.com/yaxsn itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-twitter>
                    <a href=https://twitter.com itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-facebook>
                    <a href=https://www.facebook.com itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-google>
                    <a href=https://plus.google.com itemprop="url" target="_blank"></a>
                </div>
            
        </div>
        <div class="sidebar-menu">
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">Home</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/archives"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">Archives</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/about"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">About</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/friend"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">Friend</div>
                </div>
            
        </div>
    </div>
    
        

    
        

    
        
    <div class="widget-wrap wow fadeInRight">
        <h3 class="widget-title">Archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
        </div>
    </div>


    
</aside>

                
            </div>
            <footer id="footer" class="wow fadeInUp">
    <div style="width: 100%; overflow: hidden"><div class="footer-line"></div></div>
    <div class="outer">
        <div id="footer-info" class="inner">
            
            <div>
                <span class="icon-copyright"></span>
                2020-2023
                <span class="footer-info-sep"></span>
                浅笙
            </div>
            
                <div>
                    Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;
                    Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a>
                </div>
            
            
                <div>
                    <span class="icon-brush"></span>
                    17k
                    &nbsp;|&nbsp;
                    <span class="icon-coffee"></span>
                    01:03
                </div>
            
            
                <div>
                    <span class="icon-eye"></span>
                    <span id="busuanzi_container_site_pv">Number of visits&nbsp;<span id="busuanzi_value_site_pv"></span></span>
                    &nbsp;|&nbsp;
                    <span class="icon-user"></span>
                    <span id="busuanzi_container_site_uv">Number of visitors&nbsp;<span id="busuanzi_value_site_uv"></span></span>
                </div>
            
        </div>
    </div>
</footer>

        </div>
        <nav id="mobile-nav">
    <div class="sidebar-wrap">
        <div class="sidebar-author">
            <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="浅笙" class="lazyload">
            <div class="sidebar-author-name">浅笙</div>
            <div class="sidebar-description">QQ:3561409438</div>
        </div>
        <div class="sidebar-state">
            <div class="sidebar-state-article">
                <div>Posts</div>
                <div class="sidebar-state-number">5</div>
            </div>
            <div class="sidebar-state-category">
                <div>Categories</div>
                <div class="sidebar-state-number">0</div>
            </div>
            <div class="sidebar-state-tag">
                <div>Tags</div>
                <div class="sidebar-state-number">0</div>
            </div>
        </div>
        <div class="sidebar-social">
            
                <div class=icon-github>
                    <a href=https://github.com/yaxsn itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-twitter>
                    <a href=https://twitter.com itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-facebook>
                    <a href=https://www.facebook.com itemprop="url" target="_blank"></a>
                </div>
            
                <div class=icon-google>
                    <a href=https://plus.google.com itemprop="url" target="_blank"></a>
                </div>
            
        </div>
        <div class="sidebar-menu">
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">Home</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/archives"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">Archives</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/about"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">About</div>
                </div>
            
                <div class="sidebar-menu-link-wrap">
                    <a class="sidebar-menu-link-dummy" href="/friend"></a>
                    <span class="sidebar-menu-icon"></span>
                    <div class="sidebar-menu-link">Friend</div>
                </div>
            
        </div>
    </div>
</nav>

        
<script src="https://unpkg.com/jquery@3.7.0/dist/jquery.min.js"></script>


<script src="https://unpkg.com/lazysizes@5.3.2/lazysizes.min.js"></script>


<script src="https://unpkg.com/clipboard@2.0.11/dist/clipboard.min.js"></script>



    
<script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>



    
<script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script>






<script src="/js/script.js"></script>
















    </div>
    <div class="site-search">
        <div class="algolia-popup popup">
            <div class="algolia-search">
                <span class="algolia-search-input-icon"></span>
                <div class="algolia-search-input" id="algolia-search-input"></div>
            </div>

            <div class="algolia-results">
                <div id="algolia-stats"></div>
                <div id="algolia-hits"></div>
                <div id="algolia-pagination" class="algolia-pagination"></div>
            </div>

            <span class="popup-btn-close"></span>
        </div>
    </div>
    <!-- hexo injector body_end start -->
<script src="/js/insertHighlight.js"></script>
<!-- hexo injector body_end end --></body>
    </html>

