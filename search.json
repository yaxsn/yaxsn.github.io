[{"title":"‘'第一次写文章","date":"2023-07-08T12:40:28.000Z","url":"/2023/07/08/%E2%80%98-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E6%96%87%E7%AB%A0/","categories":[["undefined",""]],"content":" 指针法 这就是为什么在某些地方大家会看到 i[arr] 这种访问数组元素的方法的原因，实际上下标法就是通过指针法来实现的，只不过编译器帮助我们做了这个操作，简化了操作难度。 指向数组的指针我们也可以定义一个指向数组的指针，例如： ​cpp int arr[] = &#123; 99, 15, 100, 888, 252 &#125;; int *p = arr; ​ arr 本身可以看做是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以int *p = arr;也可以写作int *p = &amp;arr[0];。也就是说，arr、p、&amp;arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。 如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。 数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是int *。 反过来想，p 并不知道它指向的是一个数组，p 只知道它指向的是一个整数，究竟如何使用 p 取决于程序员的编码。 使用指针访问数组元素和使用函数名没有任何区别，值得注意的是我们不同通过指针获得数组的大小，但是通过数组名却可以。 ​cpp printf(&quot;%d\\n&quot;,sizeof(arr)); //数组所占字节数 20 Byte printf(&quot;%d\\n&quot;,sizeof(p)); //指针所占字节数 4 Byte ​ 也就是说，根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。不像字符串，数组本身也没有特定的结束标志，如果不知道数组的长度，那么就无法遍历整个数组。 关于数组指针的谜题假设 p 是指向数组 arr 中第 n 个元素的指针，那么 *p++、*++p、(*p)++ 分别是什么意思呢？ *p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素。 *++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。 (*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0 个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0 个元素的值就会变为 100。 数组名和数组指针的区别虽然说数组名可以当做指针使用，但实际上数组名并不等价于指针。 数组名代表的是整个数组，具有确定数量的元素 指针是一个标量，不能确定指向的是否是一个数组 数组可以在某些情况下会自动转换为指针，当数组名在表达式中使用时，编译器会把数组名转换为一个指针常量，是数组中的第一个元素的地址，类型就是数组元素的地址类型(通过sizeof也可以看出来) 二维数组指针二维数组可以理解为每一个元素都是一个一维数组的数组，这样就可以很好的理解二维数组与指针了。 下面定义了一个2行3列的二维数组，并画出了对应的内存模型。 我们可以使用arr[0]获得第0个一维数组，然后再加上一个小标就可以获取到对应的元素，如arr[0][0]获取了第0行第0列的元素。 动态内存分配动态内存是相对静态内存而言的。所谓动态和静态就是指内存的分配方式。动态内存是指在堆上分配的内存，而静态内存是指在栈上分配的内存。 前面所写的程序大多数都是在栈上分配的，比如局部变量、形参、函数调用等。栈上分配的内存是由系统分配和释放的，空间有限，在复合语句或函数运行结束后就会被系统自动释放。而堆上分配的内存是由程序员通过编程自己手动分配和释放的，空间很大，存储自由。堆和栈后面还会专门讲，这里先了解一下。 动态分配意义 定义数组时必须指定数组的大小，使用动态分配可以在运行时调整大小。 突破函数内局部变量的作用域局限，函数结束之后，不希望变量的内存被释放。 库函数那么动态内存是怎么造出来的？在讲如何动态地把一个数组造出来之前，我们必须要先介绍 malloc 函数的使用。 mallocmalloc 是一个系统函数，它是 memory allocate 的缩写。其中memory是“内存”的意思，allocate是“分配”的意思。顾名思义 malloc 函数的功能就是“分配内存”。要调用它必须要包含头文件&lt;stdlib.h&gt;。 ​cpp void* malloc(size_t _Size); int* parr = calloc(sizeof(int) * 10); ​ malloc 函数只有一个形参，并且是整型。该函数的功能是在内存的动态存储空间即堆中分配一个长度为size的连续空间。函数的返回值是一个指向所分配内存空间起始地址的指针，类型为 void*型。 简单的理解，malloc 函数的返回值是一个地址，这个地址就是动态分配的内存空间的起始地址。如果此函数未能成功地执行，如内存空间不足，则返回空指针 NULL。 “int i&#x3D;5；”表示分配了 4 字节的“静态内存”。这里需要强调的是：“静态内存”和“静态变量”虽然都有“静态”两个字，但是它们没有任何关系。不要以为“静态”变量的内存就是“静态内存”。静态变量的关键字是 static，它与全局变量一样，都是在“静态存储区”中分配的。这块内存在程序编译的时候就已经分配好了，而且在程序的整个运行期间都存在；而静态内存是在栈中分配的，比如局部变量。 calloccalloc函数的功能与malloc函数的功能相似，都是从堆分配内存。最大的不同在于calloc会把申请的空间全部初始化为0。 ​cpp void* calloc(size_t _Count,size_t _Size); int* parr = calloc(10,sizeof(int)); ​ reallocrealloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能。 ​cpp void* realloc(void* _Block,size_t _Size); int* pnew = realloc(parr,20); ​ _Block是堆上已经存在空间的地址 _Size是目标空间大小 重新分配堆上的void指针_Block所指的空间为_Size个字节，同时会复制原有内容到新分配的堆上存储空间。注意，若_Size小于或等于原来空间的字节，则保持不变。否则会扩容。 free前面讲过，动态分配的内存空间是由程序员手动编程释放的。那么怎么释放呢？用 free 函数。 ​cpp void free(void* _Block); ​ free 函数无返回值，它的功能是释放指针变量 p 所指向的内存单元。此时 p 所指向的那块内存单元将会被释放并还给操作系统，不再归它使用。操作系统可以重新将它分配给其他变量使用。 需要注意的是，释放并不是指清空内存空间，而是指将该内存空间标记为“可用”状态，使操作系统在分配内存时可以将它重新分配给其他变量使用。 注意动态创建的内存如果不用了必须要释放。注意，一个动态内存只能释放一次。如果释放多次程序就会崩溃，因为已经释放了，不能再释放第二次。 malloc 和 free 一定要成对存在，一一对应。有 malloc 就一定要有 free，有几个 malloc 就要有几个 free，与此同时，每释放一个指向动态内存的指针变量后要立刻把它指向 NULL。 最后需要强调的是，只有动态创建的内存才能用 free 把它释放掉，静态内存是不能用free释放的。静态内存只能由系统释放。比如： ​ int a = 10; int *p = &amp;a; free(p); //error ​ 如果试图用 free(p) 把指针变量 p 所指向的内存空间释放掉，那么编译的时候不会出错，但程序执行的时候立刻就出错。 指针数组每个元素都是指针的数组叫做指针数组，即存储指针的数组。 如：int* parr[5] = &#123;NULL&#125;; parr里面存的是int*型指针，同时我们把每个指针都初始化为了NULL。接下来我们让这个数组的每个元素都指向一块动态分配的空间。 ​&#96;&#96;&#96;cppfor(int i&#x3D;0;i&lt;5;i++){ parr[i] &#x3D; malloc(sizeof(int)); *parr[i] &#x3D; i;} ​&#96;&#96;&#96; 小试牛刀"},{"title":"Hello World","date":"2023-07-08T08:13:43.104Z","url":"/2023/07/08/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]