[{"title":"作为读者的谦虚","date":"2023-07-11T01:06:37.000Z","url":"/2023/07/11/%E4%BD%9C%E4%B8%BA%E8%AF%BB%E8%80%85%E7%9A%84%E8%B0%A6%E8%99%9A/","categories":[["undefined",""]],"content":"我在北京，目睹过很多场次的作者见面会，即使是比较小众的作者，也有人数多到超出预计的读者早早抢占了坐席，看来“吃到了鸡蛋，不必见下蛋的母鸡”的说法，并没有深入人心，人们依然还是要去听讲座――重点是看看那个作者，看他和自己想象中的那个人，吻合程度有多少。然后就到了提问的环节，一些人抓住了这个机会，开始大段大段地阐述自己的看法，最后以“你认为我说的对不对？”结束提问――其实，这不是抓住机会，而是过度关注自我，忽视作者，浪费了这个机会。 我读过一篇文章，是“水晶先生”写自己拜会晚年张爱玲的经历，那时张爱玲深居简出，不见朋友，更不见读者或粉丝，“水晶先生”幸运地得到见面的机会，他却浪费了这个机会。 那是一次尴尬的拜会，也是一篇尴尬的文章。全篇都是“水晶先生”滔滔不绝地讲自己如何看待张爱玲的作品、如何看章回体小说、如何批评沈从文与钱钟书，然后张爱玲说：“嗳。”“很赞同。”唯有一处，“水晶先生”说《金瓶梅》不好，张爱玲很诧异，说自己每次读到宋蕙莲以及李瓶儿临终两段，都要大哭一场。 “水晶先生”接下来又开始为自己辩护，坚持认为《金瓶梅》写得粗糙、单调而淫秽……如果“水晶先生”能够从绵延不绝的自我关注中抽出一两秒，观察张爱玲的反应，他是否会发现她的表情是在哂笑呢？ 我在年少无知、阅读甚少的时候，也是这样一个读者。别人看动漫，看言情小说，我不屑，我找米兰?昆德拉、尼采来看，一方面为了接受采访时能够引用他们的话;另一方面，也是抱着挑剔和反驳的目的，读一两段就在旁边标注：“写得也不怎么样。”“真的么？”“我看不懂，是他表达得不清楚？” 直到我上高中的一个下午，读到赫尔曼?黑塞的《荒原狼》，其中有一段话“因为我跟你一样。因为我也和你一样孤独，和你一样不能爱生活，不能爱人，不能爱我自己，我不能严肃认真地对待生活，对待别人和自己。世上总有几个这样的人，他们对生活要求很高，对自己的愚蠢和粗野又不甘心”。 这段话穿透了纸张，穿越了时间和空间，准确地指向我的内心，让我看到一个我未曾发现过的自己。我才意识到，读书的目的不是求异，而是求同，我的幼稚和自大轰然崩塌，回归到一个读者的谦虚。 什么是一个读者的谦虚？中国古代私塾的教学方式，叫作“素读”，意思是看书的时候不带自己观点，脑袋空白地看。不在书本周围砌起预备的知识围墙，不做价值判断，不添油加醋，不预设任何目的。如同弗吉利亚·伍尔夫所说，理想的阅读是“不要向作者发号施令，而要设法变成作者自己。做他的合伙者和同伴。” 阅读，如同走进一座陌生的建筑，或是走向一个陌生的人。然后，等待。等待他走向你，与你共享他的人生。如同《金瓶梅》中清河县城的李瓶儿准确地找到旧金山的张爱玲。 我们阅读，在他人的经验中找到自己的影子，发现一群比自己优秀的人，他们四周是荒野，头顶是星辰。他们帮助我们抵抗善变的友谊、不完美的爱情、孤独引发的脆弱等一切打击，使我们能够更轻盈更辽阔地生活。 越来越多的人告诉我，读书这件事，最终会变得像采购一样——不需要自己亲自去实施，而有人替你完成。比如现在有很多渊博的人做这项工作，他们把一本书拆解、打烂、萃取、重塑，然后用几分钟的视频节目或是广播，把书中“有价值的内容”讲给你，就像电影预告片，把打斗、爆破、激情戏全部剪辑在一起，让你觉得看过“精华”之后，不再有必要看正片。 而我将永远拒绝让人替我阅读，因为阅读是极个人化的，是可以提供给我的最大乐趣之一。书的本质，是孤独的作者与破碎的社会之间的一种交流方式，作者发出声响，或许几百年后，在青灯孤照的图书馆，一个孤独而谦虚的读者报以应和的回响。 ​ 作者 蒋方舟​ "},{"title":"‘'第一次写文章","date":"2023-07-08T12:40:28.000Z","url":"/2023/07/08/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/","categories":[["undefined",""]],"content":" 指针法 这就是为什么在某些地方大家会看到 i[arr] 这种访问数组元素的方法的原因，实际上下标法就是通过指针法来实现的，只不过编译器帮助我们做了这个操作，简化了操作难度。 指向数组的指针我们也可以定义一个指向数组的指针，例如： ​cpp int arr[] = &#123; 99, 15, 100, 888, 252 &#125;; int *p = arr; ​ arr 本身可以看做是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以int *p = arr;也可以写作int *p = &amp;arr[0];。也就是说，arr、p、&amp;arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。 如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。 数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是int *。 反过来想，p 并不知道它指向的是一个数组，p 只知道它指向的是一个整数，究竟如何使用 p 取决于程序员的编码。 使用指针访问数组元素和使用函数名没有任何区别，值得注意的是我们不同通过指针获得数组的大小，但是通过数组名却可以。 ​cpp printf(&quot;%d\\n&quot;,sizeof(arr)); //数组所占字节数 20 Byte printf(&quot;%d\\n&quot;,sizeof(p)); //指针所占字节数 4 Byte ​ 也就是说，根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。不像字符串，数组本身也没有特定的结束标志，如果不知道数组的长度，那么就无法遍历整个数组。 关于数组指针的谜题假设 p 是指向数组 arr 中第 n 个元素的指针，那么 *p++、*++p、(*p)++ 分别是什么意思呢？ *p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素。 *++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。 (*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0 个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0 个元素的值就会变为 100。 数组名和数组指针的区别虽然说数组名可以当做指针使用，但实际上数组名并不等价于指针。 数组名代表的是整个数组，具有确定数量的元素 指针是一个标量，不能确定指向的是否是一个数组 数组可以在某些情况下会自动转换为指针，当数组名在表达式中使用时，编译器会把数组名转换为一个指针常量，是数组中的第一个元素的地址，类型就是数组元素的地址类型(通过sizeof也可以看出来) 二维数组指针二维数组可以理解为每一个元素都是一个一维数组的数组，这样就可以很好的理解二维数组与指针了。 下面定义了一个2行3列的二维数组，并画出了对应的内存模型。 我们可以使用arr[0]获得第0个一维数组，然后再加上一个小标就可以获取到对应的元素，如arr[0][0]获取了第0行第0列的元素。 动态内存分配动态内存是相对静态内存而言的。所谓动态和静态就是指内存的分配方式。动态内存是指在堆上分配的内存，而静态内存是指在栈上分配的内存。 前面所写的程序大多数都是在栈上分配的，比如局部变量、形参、函数调用等。栈上分配的内存是由系统分配和释放的，空间有限，在复合语句或函数运行结束后就会被系统自动释放。而堆上分配的内存是由程序员通过编程自己手动分配和释放的，空间很大，存储自由。堆和栈后面还会专门讲，这里先了解一下。 动态分配意义 定义数组时必须指定数组的大小，使用动态分配可以在运行时调整大小。 突破函数内局部变量的作用域局限，函数结束之后，不希望变量的内存被释放。 库函数那么动态内存是怎么造出来的？在讲如何动态地把一个数组造出来之前，我们必须要先介绍 malloc 函数的使用。 mallocmalloc 是一个系统函数，它是 memory allocate 的缩写。其中memory是“内存”的意思，allocate是“分配”的意思。顾名思义 malloc 函数的功能就是“分配内存”。要调用它必须要包含头文件&lt;stdlib.h&gt;。 ​cpp void* malloc(size_t _Size); int* parr = calloc(sizeof(int) * 10); ​ malloc 函数只有一个形参，并且是整型。该函数的功能是在内存的动态存储空间即堆中分配一个长度为size的连续空间。函数的返回值是一个指向所分配内存空间起始地址的指针，类型为 void*型。 简单的理解，malloc 函数的返回值是一个地址，这个地址就是动态分配的内存空间的起始地址。如果此函数未能成功地执行，如内存空间不足，则返回空指针 NULL。 “int i&#x3D;5；”表示分配了 4 字节的“静态内存”。这里需要强调的是：“静态内存”和“静态变量”虽然都有“静态”两个字，但是它们没有任何关系。不要以为“静态”变量的内存就是“静态内存”。静态变量的关键字是 static，它与全局变量一样，都是在“静态存储区”中分配的。这块内存在程序编译的时候就已经分配好了，而且在程序的整个运行期间都存在；而静态内存是在栈中分配的，比如局部变量。 calloccalloc函数的功能与malloc函数的功能相似，都是从堆分配内存。最大的不同在于calloc会把申请的空间全部初始化为0。 ​cpp void* calloc(size_t _Count,size_t _Size); int* parr = calloc(10,sizeof(int)); ​ reallocrealloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能。 ​cpp void* realloc(void* _Block,size_t _Size); int* pnew = realloc(parr,20); ​ _Block是堆上已经存在空间的地址 _Size是目标空间大小 重新分配堆上的void指针_Block所指的空间为_Size个字节，同时会复制原有内容到新分配的堆上存储空间。注意，若_Size小于或等于原来空间的字节，则保持不变。否则会扩容。 free前面讲过，动态分配的内存空间是由程序员手动编程释放的。那么怎么释放呢？用 free 函数。 ​cpp void free(void* _Block); ​ free 函数无返回值，它的功能是释放指针变量 p 所指向的内存单元。此时 p 所指向的那块内存单元将会被释放并还给操作系统，不再归它使用。操作系统可以重新将它分配给其他变量使用。 需要注意的是，释放并不是指清空内存空间，而是指将该内存空间标记为“可用”状态，使操作系统在分配内存时可以将它重新分配给其他变量使用。 注意动态创建的内存如果不用了必须要释放。注意，一个动态内存只能释放一次。如果释放多次程序就会崩溃，因为已经释放了，不能再释放第二次。 malloc 和 free 一定要成对存在，一一对应。有 malloc 就一定要有 free，有几个 malloc 就要有几个 free，与此同时，每释放一个指向动态内存的指针变量后要立刻把它指向 NULL。 最后需要强调的是，只有动态创建的内存才能用 free 把它释放掉，静态内存是不能用free释放的。静态内存只能由系统释放。比如： ​ int a = 10; int *p = &amp;a; free(p); //error ​ 如果试图用 free(p) 把指针变量 p 所指向的内存空间释放掉，那么编译的时候不会出错，但程序执行的时候立刻就出错。 指针数组每个元素都是指针的数组叫做指针数组，即存储指针的数组。 如：int* parr[5] = &#123;NULL&#125;; parr里面存的是int*型指针，同时我们把每个指针都初始化为了NULL。接下来我们让这个数组的每个元素都指向一块动态分配的空间。 ​&#96;&#96;&#96;cppfor(int i&#x3D;0;i&lt;5;i++){ parr[i] &#x3D; malloc(sizeof(int)); *parr[i] &#x3D; i;} ​&#96;&#96;&#96; 小试牛刀"},{"title":"Hello World","date":"2023-07-08T08:13:43.104Z","url":"/2023/07/08/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]